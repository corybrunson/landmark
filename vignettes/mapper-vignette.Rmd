---
title: "Constructing Nerves using landmarks"
author: "Yara Skaf"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Constructing Nerves using landmarks}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE, results='hide', include=FALSE}
library(dplyr)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
library(ggrepel)
library(tidyverse)
#library(landmark) # installed version of landmark package
devtools::load_all()
library(Mapper) # installed version of Mapper package
knitr::opts_chunk$set(echo = TRUE, fig.width = 7)
```

```{r, echo=FALSE}
# set up preset themes and colors
th <- theme(axis.line = element_line(color = "gray"),
            axis.text = element_text(color="gray", size=8),
            axis.title=element_text(size=8, color = "gray"),
            legend.position="bottom",
            legend.direction = "horizontal",
            legend.title = element_text(size = 8, face="bold"),
            legend.text = element_text(size = 8, margin = margin(t = -5)),
            strip.text = element_text(size = 10, face="bold"),
            plot.margin = unit(c(1, 2, 1, 2), "lines") )

colors_hex <- brewer.pal(n=5, name="Dark2")
```

Note that this vignette invokes the _currently installed_ versions of the "landmark" and "Mapper" packages.

### Motivation

One use case for the landmark package is the construction of a nerve for the Mapper algorithm. For a more thorough introduction to Mapper and its applications, see the [Mapper package documentation](https://github.com/peekxc/Mapper).

The following example will illustrate where Mapper depends on landmark points and the different behavior of the two landmark algorithms.

## Data & Lens

Consider the following point cloud data set $X$. Use the first coordinate of the data as the lens (filter), i.e. apply the function $f : X \longrightarrow \mathbb{R}$ defined by $f(x_1,x_2) = x_1$, to obtain lens space $f(X)$:

```{r, echo=FALSE}
# get random points with area of higher density
set.seed(0)
num_pts <- 30L
p <- rep(1L, 100)
p[66:75] <- rep(15L,10)
vals <- sample(1:100, size = num_pts, replace = TRUE, prob = p)

# data set X and lensed data f(X)
X <- data.frame("x_1" = vals/10, "x_2" = sample(1:10, num_pts, replace=TRUE))
f_X <- data.frame("f_x" = X$x_1, "y" = rep(0L, length(X$x_1)))
```


```{r, echo=FALSE, fig.height=8}
# plot data set X
gg_X <- ggplot(X, aes(x=x_1, y=x_2)) +
  geom_point(aes(col=x_1), size=3) +
  theme_minimal() +
  theme(legend.position="none") +
  coord_cartesian(xlim = c(0, 10))

# plot filtered data f_X
gg_fX <- ggplot(f_X, aes(x=f_x, y=y)) +
  geom_hline(yintercept=0, color="gray") +
  geom_point(aes(col=f_x), size=3) +
  labs(x = "", y = "", color = "f(x)") +
  theme_minimal() +
  theme(axis.text=element_blank(),
    panel.grid = element_blank(),
    legend.position="none") +
  coord_cartesian(ylim=c(0,0), xlim=c(0,10)) +
  scale_x_continuous()

plot_grid(gg_X, gg_fX, ncol=1, rel_heights=c(4,1), labels=c("X", "f(X)"), scale = 0.9, align = "v")
```


## Cover $f(X)$

The next step in the Mapper construction is to generate a cover of $f(X)$. We can do this by choosing a number of points in $f(X)$ to be the representatives, or landmarks, of the cover. Cover sets will be defined with reference to these landmark points, either as $\varepsilon$-balls (points within some distance $\varepsilon$ of these landmarks) or $k$-neighborhoods (the $k$ closest points to each landmark).

In this example, we will cover $f(X)$ by 5 sets in two different ways:

1. Use the maxmin procedure for landmark selection to generate a _ball cover_

2. Use the lastfirst procedure for landmark selection to generate a _neighborhood cover_

### Landmark selection

Choose the first $5$ landmarks and associated cover sets using both procedures. By default, both methods will use the first point in $f(X)$ as the initial landmark point to seed the algorithm. The `cover=TRUE` parameter specifies that cover sets should be returned as well as the landmark set.

The "extend" parameters (`extend_radius` / `extend_cardinality`) provide a way to force increased overlap of cover sets without affecting the chosen landmarks, which serves to increase the number of edges in the resulting nerve without changing the vertices. The landmark set is still selected based on the passed values of `num`, `radius`, and/or `cardinality` parameters; but after all landmark points have been chosen, the "size" of each cover set is increased by the extension, i.e. given extended value `extended_size = (1+mult) * size + add`. Note that the meaning of "size" differs between the two procedures-- it is interpreted as distance-based radius for maxmin, but cardinality (neighborhood size) for lastfirst.

```{r}
lmks_mm <- landmarks_maxmin(matrix(f_X$f_x), num = 5L, cover=TRUE, extend_radius=extension(mult=1))
lmks_lf <- landmarks_lastfirst(matrix(f_X$f_x), num = 5L, cover=TRUE, extend_cardinality=extension(mult=1))
```

Both landmark functions return data frames with two columns.

The `landmark` column stores the indices of the landmark points:

```{r}
lmks_mm$landmark
```

The `cover_set` column stores indices of points within each cover set:
```{r}
lmks_mm$cover_set
```

```{r}
# combine landmark and cover set data
bind_rows(
  mutate(lmks_mm, procedure = "maxmin"),
  mutate(lmks_lf, procedure = "lastfirst")
) %>%
  # unnest row indices
  tidyr::unnest(c(cover_set)) %>%
  # rename data row and define cover set names
  rename(xid = cover_set) %>%
  group_by(procedure) %>%
  mutate(cover_set = match(landmark, unique(landmark))) %>%
  ungroup() %>%
  # factorize procedure variable
  mutate(procedure = factor(procedure, levels = unique(procedure))) %>%
  # join coordinates
  mutate(x1 = X$x_1[xid], x2 = X$x_2[xid]) %>%
  # calculate cover set centroids
  group_by(procedure, cover_set) %>%
  mutate(m1 = mean(x1)) %>%
  # sort by x-centroid
  group_by(procedure) %>%
  arrange(procedure, m1, x1) %>%
  mutate(cover_set = match(cover_set, unique(cover_set))) %>%
  # shift cover sets to minimize overlap
  mutate(shift = ((cover_set + 1L) %% 2L) + 1L) %>%
  # flag landmark points
  ungroup() %>%
  mutate(cover_set = as.factor(cover_set)) %>%
  mutate(is_landmark = (landmark == xid)) %>%
  # cluster pullbacks
  group_by(procedure, cover_set) %>%
  tidyr::nest() %>%
  mutate(dist = purrr::map(data, ~ dist(as.matrix(select(.x, x1, x2))))) %>%
  mutate(clust = purrr::map(dist, hclust, method = "single")) %>%
  mutate(data = purrr::map2(data, clust,
                            ~ mutate(.x, cluster = cutree(.y, h = 2.2)))) %>%
  select(-dist, -clust) %>%
  #mutate(h = purrr::map_dbl(clust, Mapper::cutoff_first_threshold,
  #                          threshold = 1)) %>%
  #mutate(data = purrr::pmap(list(data, clust, h),
  #                          ~ mutate(..1, cluster = cutree(..2, h = ..3)))) %>%
  #select(-dist, -clust, -h) %>%
  unnest(c(data)) %>%
  # calculate cluster centroids
  group_by(procedure, cover_set, cluster) %>%
  mutate(c1 = mean(x1), c2 = mean(x2)) %>%
  ungroup() %>%
  print() -> lmks_data
```

```{r, echo=FALSE, include=FALSE}
# set up data structure
X_ids <- mutate(X, id = seq(nrow(X)))
lmks_all <- bind_rows(
  tidyr::unnest(mutate(lmks_mm, procedure = "maxmin"), cols = c(cover_set)),
  tidyr::unnest(mutate(lmks_lf, procedure = "lastfirst"), cols = c(cover_set))
)
lmks_all <- lmks_all %>%
  mutate(procedure = factor(procedure, levels = unique(procedure)),
         is_landmark = (landmark == cover_set)) %>%
  rename(pid=landmark, pt_idx=cover_set)

X_cl <- left_join(lmks_all, X_ids, by = c("pt_idx" = "id"))

get_clusters <- function(lmk_row, X_ids){
  pts <- subset(X_ids, id %in% lmk_row$cover_set)
  d <- dist(as.matrix(select(pts, c(x_1,x_2))))
  hc <- hclust(d, method="single")
  clusters <- cutree(hc, h=2)
  
  pts_cl <- mutate(pts, cluster = clusters, pid=lmk_row$landmark)
  pts_cl %>% rename(pt_idx=id)
}

lmks_mm %>%
  apply(1, get_clusters, X_ids)

mm_cl <- apply(lmks_mm, 1, get_clusters, X_ids)
mm_cl <- mm_cl %>% reduce(full_join) %>% mutate(procedure="maxmin")
lf_cl <- apply(lmks_lf, 1, get_clusters, X_ids)
lf_cl <- lf_cl %>% reduce(full_join) %>% mutate(procedure="lastfirst")

cl <- full_join(mm_cl, lf_cl)
X_cl <- left_join(X_cl, select(cl, c(pid, pt_idx, cluster, procedure)), by = c("pid", "pt_idx", "procedure"))
X_cl <- mutate(X_cl,
               procedure = factor(procedure, levels = unique(procedure)),
               pid = factor(pid, levels = unique(pid)),
               cluster = factor(cluster, levels = unique(cluster)) )

mm_data <- subset(X_cl, procedure=="maxmin")
lf_data <- subset(X_cl, procedure=="lastfirst")

# shift for plotting cover sets so they don't overlap
mm_data$shift <- rank(as.numeric(as.character(mm_data$pid)), ties.method = "min") %% 2 + 1
lf_data$shift <- rank(as.numeric(as.character(lf_data$pid)), ties.method = "min") %% 2 + 1
```

The following plots visualize the two different covers of $f(X)$:

```{r}
ggplot(lmks_data, aes(x = x1)) +
  facet_grid(. ~ procedure) +
  geom_point(aes(y = 0, size = is_landmark), color = "black", alpha = .5) +
  geom_line(aes(y = shift, color = cover_set)) +
  geom_point(aes(y = shift, size = is_landmark, color = cover_set)) +
  geom_text(data = filter(lmks_data, is_landmark),
            aes(y = shift, color = cover_set, label = landmark), nudge_y = .5) +
  scale_size_manual(values = c(1, 3)) +
  scale_y_continuous(limits = c(0, 10)) +
  labs(x = "x_1", y = "x_2", color = "cover set") +
  guides(size = FALSE, color = FALSE) +
  theme_minimal()
```

```{r cover plot, echo=FALSE, fig.height=4}
pick <- function(condition){function(d) d %>% filter_(condition)}

mm <- ggplot(mm_data, aes(x = x_1, alpha = is_landmark)) +
  facet_wrap(~ procedure) +
  geom_point(aes(y = 0, size = is_landmark), color="black", alpha=0.5) +
  geom_point(data=pick(~is_landmark==TRUE), aes(y = 0, size = is_landmark, color = pid)) +
  scale_size_manual(values = c(1, 3)) +
  geom_point(aes(y = shift, color = pid), size = 1) +
  scale_color_manual(values = rep(colors_hex, times = 2),
                     guide=guide_legend(title.position="top", title.hjust = 0.5,
                                        label.position = "bottom")) +
  scale_alpha_manual(values = c(.5, 1)) +
  scale_y_continuous(limits = c(0, 10)) +
  labs(color="Landmark ID") +
  guides(size = FALSE, alpha = FALSE) +
  theme_minimal() +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.title=element_blank(),
        panel.grid = element_blank(),
        axis.text.x = element_text(color="gray", size=8),
        axis.line.x = element_line(color = "gray"),
        legend.position="bottom",
        legend.direction = "horizontal",
        legend.title = element_text(size = 8, face="bold"),
        legend.text = element_text(size = 8, margin = margin(t = -5)),
        strip.text = element_text(size = 10, face="bold"),
        plot.margin = unit(c(1, 2, 1, 2), "lines"))
lf <- mm %+% lf_data

gridExtra::grid.arrange(mm, lf, ncol=2)
```

Notice that the area of $f(X)$ with greater point density (near 7) is handled differently by the two covering methods. Since `landmarks_maxmin()` chooses points based on Euclidean distance away from existing landmarks, only one point ($\ell_1$) is selected from the high density region. Consequently, this cover set has significantly more points than the others. In contrast, `landmarks_lastfirst()` chooses points based on the number of points in each cover set, so it selects more landmarks ($\ell_1$, $\ell_4$, $\ell_5$) within this area. Additionally, all cover sets in the neighborhood cover have roughly the same cardinality.

## Compute Pullback

Compute the _pullback_ of the cover by identifying the points in $x \in X$ mapping into each cover set under $f$. The preimages of the landmark points are highlighted for reference in the figure below, but note that the positions of landmark preimages in $X$ have no significance on clustering or in the remainder of the Mapper algorithm at all-- their only purpose is to generate cover sets in $f(X)$.

```{r}
ggplot(lmks_data, aes(x = x1, alpha = is_landmark)) +
  facet_grid(. ~ procedure) +
  geom_point(y = 0, color = "black", alpha = .5) +
  geom_point(aes(y = x2, color = cover_set, shape = cover_set,
                 size = is_landmark)) +
  geom_text(data = filter(lmks_data, is_landmark),
            aes(y = x2, color = cover_set, label = landmark), nudge_y = .5) +
  scale_size_manual(values = c(3, 4)) +
  scale_shape_manual(values = c(15L:18L, 8L)) +
  scale_alpha_manual(values = c(.5, .9)) +
  scale_y_continuous(limits = c(0, 10)) +
  labs(x = "x_1", y = "x_2", color = "cover set") +
  guides(size = FALSE, shape = FALSE, alpha = FALSE, color = FALSE) +
  theme_minimal()
```

```{r pullback plot, echo=FALSE, fig.height=4}
mm <- ggplot(mm_data, aes(x = x_1, alpha = is_landmark)) +
  facet_wrap(~ procedure) +
  geom_point(y = 0, color = "gray", shape = 16) +
  geom_point(aes(y = x_2, color = pid, shape = pid, size = is_landmark)) +
  scale_size_manual(values = c(2, 3)) +
  scale_color_manual(values = rep(colors_hex, times = 2),
                     guide=guide_legend(title.position="top", title.hjust = 0.5, label.position = "bottom")) +
  scale_shape_manual(values = rep(c(15:18, 8), times = 2)) +
  scale_alpha_manual(values = c(.5, 1)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(shape="Pullback ID", color="Pullback ID") +
  guides(size = FALSE, alpha = FALSE) +
  theme_minimal() + th

lf <- mm %+% lf_data

gridExtra::grid.arrange(mm, lf, ncol=2)

```


### Cluster
Next, perform single linkage clustering within each pullback set.

```{r}
ggplot(lmks_data, aes(x = x1)) +
  facet_grid(. ~ procedure) +
  geom_point(y = 0, color = "black", alpha = .5) +
  geom_point(aes(y = x2, color = cover_set, shape = cover_set),
             size = 3, alpha = .25) +
  geom_text_repel(aes(y = x2, color = cover_set, label = cluster),
                  box.padding = 0, point.padding = 0, min.segment.length = 0) +
  scale_shape_manual(values = c(15L:18L, 8L)) +
  scale_y_continuous(limits = c(0, 10)) +
  labs(x = "x_1", y = "x_2", color = "cover set") +
  guides(shape = FALSE, color = FALSE) +
  theme_minimal()
```

```{r cluster plot, echo=FALSE, fig.height=4}
mm <- ggplot(mm_data, aes(x = x_1)) +
  facet_wrap(~ procedure) +
  geom_point(y = 0, color = "gray", shape = 16) +
  geom_point(aes(y = x_2, color = pid, shape = pid), alpha=0.2, size=4) +
  geom_text_repel(aes(y = x_2, label=cluster, color = pid), size=3, point.padding = NA, show.legend = FALSE, segment.alpha=0.4) +
  scale_size_manual(values = c(2, 3)) +
  scale_color_manual(values = rep(colors_hex, times = 2),
                     guide=guide_legend(title.position="top", title.hjust = 0.5, label.position = "bottom")) +
  scale_shape_manual(values = rep(c(15:18, 8), times = 2)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(shape="Pullback ID", color="Pullback ID") +
  guides(size = FALSE, alpha = FALSE) +
  theme_minimal() + th

lf <- mm %+% lf_data

gridExtra::grid.arrange(mm, lf, ncol=2)
```



## Generate Nerve
Construct a _simplicial complex_ from clusters and their overlaps-- Each cluster genertes by the previous step becomes a vertex (0-simplex). Edges (1-simplices) are inserted between clusters with non-empty overlap.

First, generate vertices from clusters:

```{r}
lmks_data %>%
  select(procedure, cover_set, landmark, c1, c2, cluster) %>%
  distinct() %>%
  ggplot(aes(x = c1)) +
  facet_grid(. ~ procedure) +
  geom_point(aes(y = c2, color = cover_set, shape = cover_set),
             size = 8, alpha = .25) +
  geom_text(aes(y = c2, color = cover_set, label = cluster), size = 3) +
  scale_shape_manual(values = c(15L:18L, 8L)) +
  scale_y_continuous(limits = c(0, 10)) +
  labs(x = "x_1", y = "x_2", color = "cover set") +
  guides(shape = FALSE, color = FALSE) +
  theme_minimal()
```

```{r nerve plot, echo=FALSE, fig.height=4}
mm_clusters <- mm_data[ !duplicated( mm_data[,c("pid", "cluster")] ), ]
lf_clusters <- lf_data[ !duplicated( lf_data[,c("pid", "cluster")] ), ]

mm <- ggplot(mm_clusters, aes(x = x_1)) +
  facet_wrap(~ procedure) +
  geom_point(aes(y = x_2, color = pid, shape = pid), alpha=0.2, size=8) +
  geom_text_repel(aes(y = x_2, label=cluster, color = pid), size=3, point.padding = NA, show.legend = FALSE) +
  scale_color_manual(values = rep(colors_hex, times = 2),
                     guide=guide_legend(title.position="top", title.hjust = 0.5, label.position = "bottom")) +
  scale_shape_manual(values = rep(c(15:18, 8), times = 2)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(shape="Pullback ID", color="Pullback ID", x = "", y = "") +
  guides(size = FALSE, alpha = FALSE) +
  theme_minimal() +
  theme(axis.text=element_blank(),
        axis.ticks=element_blank(),
        panel.grid = element_blank(),
        legend.position="none",
        strip.text = element_text(size = 10, face="bold"),
        plot.margin = unit(c(1, 2, 1, 2), "lines"))
lf <- mm %+% lf_clusters

gridExtra::grid.arrange(mm, lf, ncol=2)
```


Then add edges between overlapping clusters:

```{r}
lmks_data %>%
  select(procedure, cover_set, landmark, c1, c2, cluster) %>%
  distinct() %>%
  print() -> lmks_vertices
# edges from pairwise overlaps
lmks_data %>%
  tidyr::unite(col = "cc", cover_set, cluster) %>%
  select(procedure, xid, cc) %>%
  { inner_join(., ., by = "xid", suffix = c("_1", "_2")) } %>%
  filter(procedure_1 == procedure_2 & cc_1 < cc_2) %>%
  select(xid, procedure = procedure_1, cc_1, cc_2) %>%
  tidyr::separate(cc_1, into = c("cover_set_1", "cluster_1"), sep = "_") %>%
  tidyr::separate(cc_2, into = c("cover_set_2", "cluster_2"), sep = "_") %>%
  mutate_at(vars(matches("\\_[12]$")), as.integer) %>%
  mutate_at(vars(starts_with("cover_set_")), as.factor) %>%
  left_join(lmks_vertices,
            by = c("procedure",
                   cover_set_1 = "cover_set", cluster_1 = "cluster")) %>%
  rename_at(vars(matches("^c[12]$")), ~ paste(., "1", sep = "_")) %>%
  select(-landmark) %>%
  left_join(lmks_vertices,
            by = c("procedure",
                   cover_set_2 = "cover_set", cluster_2 = "cluster")) %>%
  rename_at(vars(matches("^c[12]$")), ~ paste(., "2", sep = "_")) %>%
  select(-landmark) %>%
  print() -> lmks_edges
lmks_vertices %>%
  ggplot(aes(x = c1)) +
  facet_grid(. ~ procedure) +
  geom_segment(data = lmks_edges,
               aes(x = c1_1, y = c2_1, xend = c1_2, yend = c2_2),
               size = 1, alpha = .75) +
  geom_point(aes(y = c2, color = cover_set, shape = cover_set),
             size = 5, alpha = .5) +
  #geom_text(aes(y = c2, color = cover_set, label = cluster), size = 2) +
  geom_text_repel(aes(y = c2, color = cover_set, label = cluster), size = 3,
                  box.padding = 0, point.padding = 0, min.segment.length = 0) +
  scale_shape_manual(values = c(15L:18L, 8L)) +
  scale_y_continuous(limits = c(0, 10)) +
  labs(x = "x_1", y = "x_2", color = "cover set") +
  guides(shape = FALSE, color = FALSE) +
  theme_minimal()
```

```{r, echo=FALSE}

get_nerve <- function(cluster_list){
  gg <- ggplot(X, aes(x=x_1, y=x_2))

  for( i in seq_along(cluster_list) ){
    cl <- unique(cluster_list[[i]]$cluster)
    clusters <- data.frame(x=rep(i, length(cl)), y=cl)
    
    j = i+1
    while(j <= length(cluster_list)){
      cl_j <- unique(cluster_list[[j]]$cluster)
      clusters_j <- data.frame(x=rep(j, length(cl_j)), y=cl_j)
      
      overlap <- inner_join(cluster_list[[i]], cluster_list[[j]], by=c("x_1", "x_2"))
      edges <- data.frame(x1=rep(i,nrow(overlap)), y1=overlap$cluster.x,
                          x2=rep(j,nrow(overlap)), y2=overlap$cluster.y)
      gg <- gg + geom_segment(data = edges, aes(x = x1, y = y1, xend = x2, yend = y2), color="black")
      j = j + 1
    }
    
    gg <- gg + geom_point(data=clusters, aes(x=x, y=y), color=colors_hex[i], size=8) +
    geom_text(data=clusters, aes(x=x, y=y, label=y), color="white")
  }
  
  gg + 
    labs(x = "", y = "") +
    theme_minimal() +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.x=element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
    )
}


cluster_list_lf = list()
for( i in seq_along(lmks_lf$landmark) ){
  cover_set <- lmks_lf$cover_set[[i]]
  pts <- X[cover_set,]
  d <- dist(as.matrix(pts))
  hc <- hclust(d, method="single")
  clusters <- cutree(hc, h=2)
  pts_cl <- mutate(pts, cluster = clusters)
  cluster_list_lf[[i]] <- pts_cl
}

cluster_list_mm = list()
for( i in seq_along(lmks_mm$landmark) ){
  cover_set <- lmks_mm$cover_set[[i]]
  pts <- X[cover_set,]
  d <- dist(as.matrix(pts))
  hc <- hclust(d, method="single")
  clusters <- cutree(hc, h=2)
  pts_cl <- mutate(pts, cluster = clusters)
  cluster_list_mm[[i]] <- pts_cl
}

```


```{r, echo=FALSE, fig.height=4}
nerve_mm <- get_nerve(cluster_list_mm)
nerve_lf <- get_nerve(cluster_list_lf)

plot_grid(nerve_mm, nerve_lf, ncol=2, scale=0.9,
          labels=c("maxmin nerve", "lastfirst nerve"),
          label_size = 10)
```


## Mapper
This process is roughly equivalent to building the following mappers on this data.

```{r, eval=FALSE}
m <- MapperRef$new(as.matrix(X))$
  use_filter(filter = as.matrix(X[,1,drop=FALSE]))$
  use_cover(cover="landmark_ball", num_sets=5L)$
  construct_k_skeleton(k=1L)
```

```{r, eval=FALSE}
m <- MapperRef$new(as.matrix(X))$
  use_filter(filter = as.matrix(X[,1,drop=FALSE]))$
  use_cover(cover="neighborhood", num_sets=5L)$
  construct_k_skeleton(k=1L)
```


